#!/usr/bin/env python3

# generate_test_driver.py
#
# Copyright The Mbed TLS Contributors
# SPDX-License-Identifier: Apache-2.0 OR GPL-2.0-or-later

"""
Generate a TF-PSA-Crypto test driver
"""
import sys

from fnmatch import fnmatch
from pathlib import Path
from typing import Iterable, List, Set

import scripts_path # pylint: disable=unused-import
from mbedtls_framework import build_tree
from mbedtls_framework import test_driver

EXCLUDE_FILES = {
    "asn1*",
    "base64*",
    "crypto_builtin_key_derivation.h",
    "lmots*",
    "lms.c",
    "md.c",
    "memory_buffer_alloc.c",
    "nist_kw.c",
    "pem.c",
    "pk*",
    "platform*",
    "threading*",
}

def iter_code_files(root: Path) -> Iterable[Path]:
    """
    Iterate over all "*.c" and "*.h" files found recursively under the `include`
    and `src` subdirectories of `root`.
    """
    for directory in ("include", "src"):
        directory_path = root / directory
        for ext in (".c", ".h"):
            yield from directory_path.rglob(f"*{ext}")

def get_src_relpaths(builtin: Path, exclude_files: Set[str]) -> List[Path]:
    """
    Return the relative paths of all *.c and *.h files under `builtin`,
    excluding those whose names match any of the patterns in `exclude_files`.

    The returned paths are relative to `builtin`.
    """

    out = []
    for file in iter_code_files(builtin):
        if not any(fnmatch(file.name, pattern) for pattern in exclude_files):
            out.append(file.relative_to(builtin))
    out.sort()
    return out

def get_dst_relpaths(src_relpaths: List[Path], driver: str) -> List[Path]:
    """
    Return the relative paths of the *.c and *.h files generated by the script.

    These paths are the same as in `src_relpaths`, except that occurrences of
    `mbedtls` in `include/mbedtls/...` paths are replaced with `driver`.

    The returned paths are relative to `dst_dir`.
    """

    out = []
    for path in src_relpaths:
        parts = list(path.parts)
        if parts[0] == "include" and parts[1] == "mbedtls":
            parts[1] = driver
        out.append(Path(*parts))

    return out

def main():
    """
    Main function of this program
    """
    parser = test_driver.get_parsearg_base()
    parser.add_argument('--list-vars-for-cmake', nargs="?", const="__AUTO__", metavar="FILE",
                        help="Generate a file to be included from a CMakeLists.txt.\n"
                        "The file defines CMake list variables with the script's\n"
                        "inputs/outputs files. If FILE is omitted, the output \n"
                        "name defaults to '<DRIVER>-list-vars.cmake'.")

    args = parser.parse_args()

    if not build_tree.looks_like_tf_psa_crypto_root("."):
        raise RuntimeError("This script must be run from TF-PSA-Crypto root.")

    builtin = Path("drivers/builtin")
    if not builtin.is_dir():
        raise RuntimeError("Do not find expected drivers/builtin directory.")
    src_relpaths = get_src_relpaths(builtin, EXCLUDE_FILES)

    dst_dir = Path(args.dst_dir)
    if not dst_dir.is_dir():
        raise RuntimeError(f"Do not find expected {args.dst_dir} directory.")

    if args.list_vars_for_cmake:
        fname = f"{args.driver}-list-vars.cmake" \
                if args.list_vars_for_cmake == "__AUTO__" else args.list_vars_for_cmake

        with open(dst_dir / fname, "w") as f:
            f.write(f"set({args.driver}_input_files " + \
                     " ".join(str(path) for path in src_relpaths) + ")\n\n")
            f.write(f"set({args.driver}_files " + \
                    " ".join(str(path) \
                    for path in get_dst_relpaths(src_relpaths, args.driver)) + ")\n\n")
            f.write(f"set({args.driver}_src_files " + \
                    " ".join(str(path) \
                    for path in src_relpaths if path.suffix == ".c") + ")")
        return

if __name__ == "__main__":
    sys.exit(main())
